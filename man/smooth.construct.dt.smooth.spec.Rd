% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/dt_basis.R
\name{smooth.construct.dt.smooth.spec}
\alias{smooth.construct.dt.smooth.spec}
\title{Domain Transformation basis constructor}
\usage{
\method{smooth.construct}{dt.smooth.spec}(object, data, knots)
}
\arguments{
\item{object}{a smooth specification object, generated by \code{s()},
\code{te()}, \code{ti()}, or \code{t2()}, with \code{bs="dt"}}

\item{data}{a list containing just the data (including any by variable)
required by this term, with names corresponding to \code{object$term}
(and \code{object$by}). The \code{by} variable is the last element.}

\item{knots}{a list containing any knots supplied for basis setup - in same
   order and with same names as \code{data}. Can be \code{NULL}.}
}
\value{
An object of class "dt.smooth". This will contain all the elements
  associated with the \code{\link[mgcv]{smooth.construct}} object from the
  inner smooth (defined by \code{xt$bs}), in addition to:
  \enumerate{
    \item tf: the named list of transformation functions applied to the
    input data
    \item class: the class of the smooth object for the inner smooth
  }
}
\description{
The \code{dt} basis allows for any of the standard \code{mgcv} (or
  user-defined) bases to be aplied to a transformed version of the
  original terms. Smooths may be of any number of terms. Transformations
  are specified by supplying a function of any or all of the original terms.
  "\code{by}" variables are not transformed.
}
\details{
\code{object} should be creaated with an \code{xt} argument. For
non-tensor-product smooths, this will be a list with the following elements:
\enumerate{
  \item \code{tf}: a function or character string (or list of functions
  and/or character strings) defining the coordinate transormations; see
  further details below.
  \item \code{bs} (optional): character string indicating the \code{bs} for
  the basis applied to the transformed coordinates; if empty, the appropriate
  defaults are used.
}
For tensor product smooths, the \code{xt} argument could entered in the above
form, in which case the same basis will be applied to each margin. If a
different basis is desired for each margin, this could be done by setting
\code{xt} to a list of such lists. In this case, \code{tf} need only be
included in one of those lists.

Let \code{nterms = length(object$terms)}. The \code{tf} element can take one
of the following forms:
\enumerate{
  \item a function of \code{nargs} arguments, where \code{nargs <= nterms}.
    If \code{nterms > 1}, it is assumed that this function will be applied to
    the first term of \code{object$term}. If all argument names of the
    function are term names, then those arguments will correspond to those
    terms; otherwise, they will correspond to the first \code{nargs} terms in
    \code{object$term}.
  \item a character string corresponding to one of the built-in
    transformations (listed below).
  \item A list of length \code{ntfuncs}, where \code{ntfuncs<=nterms},
    containing either the functions or character strings described above. If
    this list is named with term names, then the transformation functions
    will be applied to those terms; otherwise, they will be applied to the
    first \code{ntfuncs} terms in \code{object$term}.
}
The following character strings are recognized as built-in transformations:
\itemize{
  \item \code{"log"}: log transformation (one variable)
  \item \code{"ecdf"}: empirical cumulative distribution function (one variable)
  \item \code{"linear01"}: linearly rescale from 0 to 1 (one variable)
  \item \code{"s-t"}: first term ("s") minus the second term ("t") (two variables)
  \item \code{"s/t"}: first term ("s") divided by the second term ("t") (two variables)
}

IMPORTANT WHEN WRITING YOUR OWN FUNCTIONS:

Some transformations rely on a function of the data used to fit the model,
e.g. the max or min of this data. When making predictions based on these
transformaitons, the transformation function will usually need access to the
original data used to fit the model, not the data used for the prediction. In
order to access this data, you can refer to the argument name appended with
a zero ("0") within the function. For exapmle, suppose you want to scale
the term linearly so that the data used to define the basis ranges from
0 to 1. The wrong way to define this transformation function:
\code{
   function(x) {(x - max(x))/(max(x) - min(x))}
}
This function will result in incorrect predictions if the range of data for
which preditions are being made is not the same as the range of data that was
used to define the basis. The proper way to define this function:
\code{
   function(x) {(x - max(x0))/(max(x0) - min(x0))}
}
By refering to \code{x0} instead of \code{x}, you are indicating that you
want to use the original data instead of the current data. This may seem
strange to refer to a variable that is not one of the arguments, but the
\code{"dt"} explicity defines this variable in the basis constructor and
places it in the environment of the transformation function.
}
\author{
Jonathan Gellar
}
\seealso{
\code{\link[mgcv]{smooth.construct}}
}

