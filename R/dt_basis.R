#' Domain Transformation basis constructor
#' 
#' The \code{dt} basis allows for any of the standard \code{mgcv} (or
#'   user-defined) bases to be aplied to a transformed version of the
#'   original terms. Smooths may be of any number of terms. Transformations
#'   are specified by supplying a function of any or all of the original terms.
#' 
#' @param object a smooth specification object, generated by \code{s()},
#'   \code{te()}, \code{ti()}, or \code{t2()}, with \code{bs="dt"}
#' @param data a list containing just the data (including any by variable)
#'   required by this term, with names corresponding to \code{object$term}
#'   (and \code{object$by}). The \code{by} variable is the last element.
#' @param knots a list containing any knots supplied for basis setup - in same
#'    order and with same names as \code{data}. Can be \code{NULL}.
#' 
#' @details
#' \code{object} should be creaated with an \code{xt} argument. For
#' non-tensor-product smooths, this will be a list with the following elements:
#' \enumerate{
#'   \item \code{tf}: a function or character string (or list of functions
#'   and/or character strings) defining the coordinate transormations; see
#'   further details below.
#'   \item \code{bs} (optional): character string indicating the \code{bs} for
#'   the basis applied to the transformed coordinates; if empty, the appropriate
#'   defaults are used.
#' }
#' For tensor product smooths, the \code{xt} argument could entered in the above
#' form, in which case the same basis will be applied to each margin. If a
#' different basis is desired for each margin, this could be done by setting
#' \code{xt} to a list of such lists. In this case, \code{tf} need only be
#' included in one of those lists.
#' 
#' Let \code{nterms = length(object$terms)}. The \code{tf} element can take one
#' of the following forms:
#' \enumerate{
#'   \item a function of \code{nargs} arguments, where \code{nargs <= nterms}.
#'     If \code{nterms > 1}, it is assumed that this function will be applied to
#'     the first term of \code{object$term}. If all argument names of the
#'     function are term names, then those arguments will correspond to those
#'     terms; otherwise, they will correspond to the first \code{nargs} terms in
#'     \code{object$term}.
#'   \item a character string corresponding to one of the built-in
#'     transformations (listed below).
#'   \item A list of length \code{ntfuncs}, where \code{ntfuncs<=nterms},
#'     containing either the functions or character strings described above. If
#'     this list is named with term names, then the transformation functions
#'     will be applied to those terms; otherwise, they will be applied to the
#'     first \code{ntfuncs} terms in \code{object$term}.
#' }
#' The following character strings are recognized as built-in transformations:
#' TO BE COMPLETED.
#' 
#' 
#' @author Jonathan Gellar
#' @return An object of class "dt.smooth". See
#'    \code{\link[mgcv]{smooth.construct}} for the elements it will contain.
#' 

smooth.construct.dt.smooth.spec <- function(object, data, knots) {
  # Constructor method for parametric bivariate basis
  
  # Input Checks (TO DO)
  
  
  # Extract transformation functions
  tf <- if (class(object) %in% c("tensor.smooth.spec", "t2.smooth.spec")) {
    x <- sapply(chk$margin, function(mar) {
      mar$xt$tf
    })
    x[!sapply(x, is.null)][[1]]
  } else {
    object$xt$tf
  }
  nt <- length(object$term)
  
  # Make tf a list of functions (if it isn't already)
  if (!is.list(tf)) tf <- list(tf)
  tf <- lapply(tf, function(f) {
    if (is.character(f) & nt==2) {
      if (f=="s-t") {
        function(s,t) s-t
      } else if (f=="s/t") {
        function(s,t) s/t
      } else {
        stop("Unrecognized character string for 'dt' transformation function")
      }
    } else if (is.function(f)) {
      f
    } else stop("Unrecognized type for 'dt' transformation function")
  })
  
  # Names of tf are the names of the variables to transform
  if (is.null(names(tf)))
    # Unnamed: use the first length(tf) terms as the names
    names(tf) <- object$term[1:length(tf)]
  
  # Transform data
  tdata <- lapply(tf, function(f) {
    args <- formals(f)
    argnms <- names(args)
    if (length(args) > length(object$term))
      stop("Transformation function of too many arguments is supplied")
    if (!(all(argnms) %in% object$term))
      # If argnms aren't term names, defaults to first length(args) terms
      argnms <- object$term[1:length(args)]
    if (!all(argnms %in% names(data))) {
      miss <- argnms[!(argnms %in% names(data))]
      stop(paste0("Variable(s) ", paste(argnms[miss], collapse=", "),
                  " needed but not supplied to smooth constructor"))
    } else {
      calldat <- data[argnms]
    }
    names(calldat) <- names(args)
    do.call(f, calldat)
  })
  
  # Include untransformed data (if any)
  untr <- names(data)[!(names(data) %in% names(tdata))]
  tdata[untr] <- data[untr]
    
  # Modify smooth.spec object
  if (class(object) %in% c("tensor.smooth.spec", "t2.smooth.spec")) {
    object$margin <- lapply(object$margin, function(mar) {
      xt <- mar$xt
      bs <- ifelse(is.null(xt$bs), "tp", xt$bs)
      class(mar) <- paste0(bs, ".smooth.spec")
      mar$xt <- xt[!(names(xt) %in% c("tf", "bs"))]
      mar
    })
  } else {
    # "s" smooth
    xt <- object$xt
    bs <- ifelse(is.null(xt$bs), "tp", xt$bs)
    class(object) <- paste0(bs, ".smooth.spec")
    object$xt <- xt[!(names(xt) %in% c("tf", "bs"))]
  }
  
  # Create smooth and modify return object
  sm <- smooth.construct(object, data = tdata, knots = knots)
  sm$tf <- tf
  sm$class <- class(sm)
  class(sm) <- "dt.smooth"
  sm
}



#' Predict.matrix method for dt basis

Predict.matrix.dt.smooth <- function(object, data) {
  # Prediction method for parameteric bivariate basis
  
  tf <- object$tf
  tdata <- lapply(tf, function(f) {
    args <- formals(f)
    argnms <- names(args)
    if (!(all(argnms) %in% object$term))
      # If argnms aren't term names, defaults to first length(args) terms
      argnms <- object$term[1:length(args)]
    if (!all(argnms %in% names(data))) {
      miss <- argnms[!(argnms %in% names(data))]
      stop(paste0("Variable(s) ", paste(argnms[miss], collapse=", "),
                  " needed but not supplied to Predict.matrix"))
    } else {
      calldat <- data[argnms]
    }
    names(calldat) <- names(args)
    do.call(f, calldat)
  })
  
  # Include untransformed data (if any)
  untr <- names(data)[!(names(data) %in% names(tdata))]
  tdata[untr] <- data[untr]
  
  # Evaluate and return prediction matrix at transformed locations
  Predict.matrix(object, tdata)
}
