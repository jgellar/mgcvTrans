#' Domain Transformation basis constructor
#' 
#' The \code{dt} basis 
#' 
#' @param object a smooth specification object, generated by \code{s()},
#'   \code{te()}, \code{ti()}, or \code{t2()}
#' @param data a list containing just the data (including any by variable)
#'   required by this term, with names corresponding to \code{object$term}
#'   (and \code{object$by}). The \code{by} variable is the last element.
#' @param knots a list containing any knots supplied for basis setup - in same
#'    order and with same names as \code{data}. Can be \code{NULL}.
#' 
#' @author Jonathan Gellar
#' @return An object of class "dt.smooth". See
#'    \code{\link[mgcv]{smooth.construct}} for the elements it will contain.
#' 

smooth.construct.dt.smooth.spec <- function(object, data, knots) {
  # Constructor method for parametric bivariate basis
  
  # Input Checks (TO DO)
  
  
  # Extract transformation functions
  tf <- if (class(object) %in% c("tensor.smooth.spec", "t2.smooth.spec")) {
    x <- sapply(chk$margin, function(mar) {
      mar$xt$tf
    })
    x[!sapply(x, is.null)][[1]]
  } else {
    object$xt
  }
  nt <- length(object$term)
  
  # Make tf a list of functions (if it isn't already)
  if (!is.list(tf)) tf <- list(tf)
  tf <- lapply(tf, function(f) {
    if (is.character(f) & nt==2) {
      if (f=="s-t") {
        function(s,t) s-t
      } else if (f=="s/t") {
        function(s,t) s/t
      } else {
        stop("Unrecognized character string for 'dt' transformation function")
      }
    } else if (is.function(f)) {
      f
    } else stop("Unrecognized type for 'dt' transformation function")
  })
  
  # Names of tf are the names of the variables to transform
  if (is.null(names(tf)))
    # Unnamed: use the first length(tf) terms as the names
    names(tf) <- object$term[1:length(tf)]
  
  # Transform data
  tdata <- lapply(tf, function(f) {
    args <- formals(f)
    argnms <- names(args)
    if (length(args) > length(object$term))
      stop("Transformation function of too many arguments is supplied")
    if (!(all(argnms) %in% object$term))
      # If argnms aren't term names, defaults to first length(args) terms
      argnms <- object$term[1:length(args)]
    if (!all(argnms %in% names(data))) {
      miss <- argnms[!(argnms %in% names(data))]
      stop(paste0("Variable(s) ", paste(argnms[miss], collapse=", "),
                  " needed but not supplied to smooth constructor"))
    } else {
      calldat <- data[argnms]
    }
    names(calldat) <- names(args)
    do.call(f, calldat)
  })
  
  # Include untransformed data (if any)
  untr <- names(data)[!(names(data) %in% names(tdata))]
  tdata[untr] <- data[untr]
    
  # Modify smooth.spec object
  if (class(object) %in% c("tensor.smooth.spec", "t2.smooth.spec")) {
    object$margin <- lapply(object$margin, function(mar) {
      xt <- mar$xt
      bs <- ifelse(is.null(xt$bs), "tp", xt$bs)
      class(mar) <- paste0(bs, ".smooth.spec")
      mar$xt <- xt[!(names(xt) %in% c("tf", "bs"))]
      mar
    })
  } else {
    # "s" smooth
    xt <- object$xt
    bs <- ifelse(is.null(xt$bs), "tp", xt$bs)
    class(object) <- paste0(bs, ".smooth.spec")
    object$xt <- xt[!(names(xt) %in% c("tf", "bs"))]
  }
  
  # Create smooth and modify return object
  sm <- smooth.construct(object, data = tdata, knots = knots)
  sm$tf <- tf
  sm$class <- class(sm)
  class(sm) <- "dt.smooth"
  sm
}



#' Predict.matrix method for dt basis

Predict.matrix.dt.smooth <- function(object, data) {
  # Prediction method for parameteric bivariate basis
  
  tf <- object$tf
  tdata <- lapply(tf, function(f) {
    args <- formals(f)
    argnms <- names(args)
    if (!(all(argnms) %in% object$term))
      # If argnms aren't term names, defaults to first length(args) terms
      argnms <- object$term[1:length(args)]
    if (!all(argnms %in% names(data))) {
      miss <- argnms[!(argnms %in% names(data))]
      stop(paste0("Variable(s) ", paste(argnms[miss], collapse=", "),
                  " needed but not supplied to Predict.matrix"))
    } else {
      calldat <- data[argnms]
    }
    names(calldat) <- names(args)
    do.call(f, calldat)
  })
  
  # Include untransformed data (if any)
  untr <- names(data)[!(names(data) %in% names(tdata))]
  tdata[untr] <- data[untr]
  
  # Evaluate and return prediction matrix at transformed locations
  Predict.matrix(object, tdata)
}
