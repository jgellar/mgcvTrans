#' Scaled thin plate regression spline basis
#' 
#' The \code{tp} basis in \code{mgcv} fits thin plate regression splines over
#' any number of variables. Since these are radial basis functions, they
#' require the variables that are smoothed over to be on similar scales. This
#' basis is a modified thin plate regression spline basis that pre-transforms
#' the variables to a common scale.
#' 
#' EXPERIMENTAL.... NOT YET FULLY IMPLEMENTED! USE AT YOUR OWN RISK!
#' 
#' @param object a smooth specification object, generated by \code{s()},
#'   \code{te()}, \code{ti()}, or \code{t2()}, with \code{bs="tps"}. The type of
#'   variable transformation is specified using the \code{xt} argument; see Details.
#' @param data a list containing just the data (including any by variable)
#'   required by this term, with names corresponding to \code{object$term}
#'   (and \code{object$by}). The \code{by} variable is the last element.
#' @param knots a list containing any knots supplied for basis setup - in same
#'    order and with same names as \code{data}. Can be \code{NULL}.
#' 
#' @details
#' 
#' Currently, two types of transformations are allowed, specified with the
#' \code{xt} argument in the smooth specification:
#' 
#' \enumerate{
#'   \item \code{xt = "unit"}: re-scales all variables linearly to the unit square
#'   \item \code{xt = "sd"}: divides all variables by their standard deviations,
#'     so that each one is expressed in standard deviation units.
#' }
#' 
#' 
#' @author Jonathan Gellar \email{JGellar@@mathematica-mpr.com}
#' @seealso \code{\link[mgcv]{smooth.construct}},
#'          \code{\link[mgcv]{smooth.construct.tp.smooth.spec}}
#' 
#' @examples
#' library(mgcv)
#' N <- 100
#' x <- sample(-3:3, N, replace=TRUE)
#' y <- sin(2*pi*x/6) + rnorm(N, sd=.5)
#' 
#' 
#' 

smooth.construct.tps.smooth.spec <- function(object, data, knots) {
  
  # Transform x's based on xt argument
  
  method <- ifelse(is.null(object$xt), "unit", object$xt)
  if (method == "unit") {
    rng <- sapply(object$feefaefaf, range)
    
    
  } else if (method == "sd") {
    
    
  } else
    stop("xt argument of tps smooth must be either \"unit\" or \"sd\". ")
  
  
  k <- object$bs.dim
  interp <- ifelse(is.null(object$xt), "linear", object$xt)
  knots <- knots[[object$term]]
  if (is.null(knots)) {
    knots <- unique(data[[1]])
  }
  knots <- knots[order(knots)]
  
  if (k!=-1 & k!=length(knots)) {
    warning("ignoring k due to mismatch with the number of knots")
  }
  k <- length(knots)
  
  # Model matrix
  X <- if (all(data[[1]] %in% knots)) {
    # No interpolation needed
    model.matrix(~factor(data[[1]], levels=knots))
  } else {
    # Requires interpolation
    f0 <- model.matrix(~factor(knots))
    sapply(1:nrow(f0), function(j) {
      if (tolower(interp)=="linear") {
        approx(knots, f0[,j], data[[1]])$y
      } else if (tolower(interp) %in% c("loess", "lowess")) {
        predict(loess(y ~ x, data=data.frame(y=f0[,j], x=knots)),
                newdata=data.frame(x=data[[1]]))
      } else if (tolower(interp)%in% c("bs", "bspline")) {
        predict(mgcv::gam(y ~ s(x, bs="ps"), data=data.frame(y=f0[,j], x=knots)),
                newdata=data.frame(x=data[[1]]))
        #stop("b-spline interpolation not yet implemented")
      } else {
        stop(paste0("Interpolation method ", object$interpolation,
                    " not supported."))
      }
    })
  }
  
  # Difference Penalty
  m <- object$p.order
  if (is.na(m)) m <- 2 # Default
  L <- diag(k)
  for (i in 1:m) L <- diff(L)
  L1 <- L[nrow(L),]
  for (i in 1:m) {
    L1 <- c(0, L1[-k])
    L <- rbind(L, L1)
  }
  D <- t(L) %*% L
  
  # Modify return object
  object$X <- X
  object$S <- list(D)
  object$knots <- knots
  object$bs.dim <- k
  object$rank <- qr(D)$rank
  object$null.space.dim <- k - object$rank
  object$df <- k #need this for gamm
  object$interpolation <- interp
  class(object) <- "ar.smooth"
  object
}

#' Predict.matrix method for ar basis
#' 
#' @param object a \code{ar.smooth} object created by
#'   \code{\link{smooth.construct.ar.smooth.spec}}, see
#'   \code{\link[mgcv]{smooth.construct}}
#' @param data  see \code{\link[mgcv]{smooth.construct}}
#' @return design matrix for \code{dt} terms
#' @author Jonathan Gellar
#' 
Predict.matrix.ar.smooth <- function(object, data) {
  # Prediction method for parameteric ar basis
  if (all(data[[1]] %in% object$knots)) {
    # No interpolation needed
    newx <- factor(data[[1]], levels=object$knots)
    model.matrix(~newx)
  } else {
    # Requires interpolation!
    f0 <- model.matrix(~factor(object$knots))
    sapply(1:nrow(f0), function(j) {
      if (object$interpolation=="linear") {
        approx(object$knots,f0[,j], data[[1]])$y
      } else if (object$interpolation %in% c("loess", "lowess")) {
        predict(loess(y ~ x, data=data.frame(y=f0[,j], x=object$knots)),
                newdata=data.frame(x=data[[1]]))
      } else if (object$interpolation %in% c("bs", "bspline")) {
        predict(mgcv::gam(y ~ s(x, bs="ps", k=object$bs.dim, sp=0),
                    data=data.frame(y=f0[,j], x=object$knots)),
                newdata=data.frame(x=data[[1]]))
      } else {
        stop(paste0("Interpolation method ", object$interpolation,
                    " not supported."))
      }
    })
  }
}

